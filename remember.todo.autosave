11/29/2015

- [Priority]:
	It's pretty clear that some very, very important things need to be done before moving on. The code base is pretty mangled, and things aren't as organized as they should be.
	
	[Major Tasks]:

	* This ties in with the environment maps; either way, you should redesign your draw surfaces to be matched by surfacenormal in addition to the other parameters
	they employ; this will allow for more flexibility, the caching and performance benefits will be retained, and you'll have a better working environment map.
	
	* Break up the code in renderer.cpp into separately organized modules: the class is becoming disgustingly big, and there's a lot of "dead code"
	in there which shouldn't be used.
		- Be sure to take into account the fact that you'll need to sort 
		the shaders according to their specified heuristic.
		- You'll also need to support WebGL, which means getting rid of some things like texture arrays and UBOs.
		In order to achieve this, you'll be better off replacing them optimizations which have been proven
		(e.g., texture atlas). All uniforms for a shader parameter can be stored in something which is local
		in a separate rendering mechanism as well; this way, whenever a program is bound, it can load the values
		automatically (like the modelView matrix, etc). Emulated behavior isn't awesome, but it's better than
        nothing. See [2]

	* After you're finished refactoring, you'll want to work on the Emscripten port.

    [Notes]:

	* There's a weird bug which causes strange color flashes, when the faces are rendered separately (i.e., without the draw surfaces). My guess is
	this is likely to do with the texture arrays (are they being unbound after the draw is made?), but I'm not sure.
	
- Models

- Lightvols

- Environment Maps:  
	While the drawsurfaces have neighboring/similar faces grouped together, it's very possible that there can be varying surface normals within a single drawsurface.
	This isn't good, because the renderer doesn't currently take this into account. It's going to need to be able to support this.

- Sorting shaders:
	Shaders are depth sorted against each other. What this means, exactly, I'm not sure, but this will need some more time to figure out.
	

- Game Units: 
	* Incorporating these into the renderer will be important: it should aid in ensuring that the scaling and spread of things like texture coordinates and
	deformed tessellations will be properly computed. (see: http://toolz.nexuizninjaz.com/shader/shader/section2.htm#2.4.2 section 2.4.7 "measurements")

- Ability to save camera position/orientation and load it later.


[2 - GL features which are not supported by WebGL]:
    (NOTE: mipmapping is currently disabled, to make the process of porting easier)
    (NOTE: localOverrideFlags which are added to teh shader/stages are not taken into account with the new image loading function)

    - UBOs
    - VAOs
    - Texture Arrays
    - GLSL Extensions
    - Current GLSL syntax/layer

    Progress
    ========
    - ###A few functions have been written to handle image loading and what-not. Next thing to do would be to implement a mechanism similar to
    ###the textureArray_t which uses features available only to GLES 2.

    - Now that the image loading has been taken care of, 

    - Samplers
