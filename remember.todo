11/29/2015

- [Priority]:
	It's pretty clear that some very, very important things need to be done before moving on. The code base is pretty mangled, and things aren't as organized as they should be.
	
	[Major Tasks]:

	* This ties in with the environment maps; either way, you should redesign your draw surfaces to be matched by surfacenormal in addition to the other parameters
	they employ; this will allow for more flexibility, the caching and performance benefits will be retained, and you'll have a better working environment map.
	(NOTE: bsp vertices do have normals - you should definitely stop passing in face surface normals and pass the normals in as vertex attributes.
	You'll need to switch layouts obviously each time this is done, but if it works then it works).


	* Break up the code in renderer.cpp into separately organized modules: the class is becoming disgustingly big, and there's a lot of "dead code"
	in there which shouldn't be used.
		- Be sure to take into account the fact that you'll need to sort 
		the shaders according to their specified heuristic.
		- You'll also need to support WebGL, which means getting rid of some things like texture arrays and UBOs.
		In order to achieve this, you'll be better off replacing them optimizations which have been proven
		(e.g., texture atlas). All uniforms for a shader parameter can be stored in something which is local
		in a separate rendering mechanism as well; this way, whenever a program is bound, it can load the values
		automatically (like the modelView matrix, etc). Emulated behavior isn't awesome, but it's better than
        nothing. See [2]

	* After you're finished refactoring, you'll want to work on the Emscripten port.

    [Notes]:

	* There's a weird bug which causes strange color flashes, when the faces are rendered separately (i.e., without the draw surfaces). My guess is
	this is likely to do with the texture arrays (are they being unbound after the draw is made?), but I'm not sure.

	* On the Texture Atlas: simply modf'ing the bsp vertex texture coords doesn't appear to be the solution. It's likely
	that there will be many different vertices which will have the same world space position, albeit with different texture coords. 
	This may mean that the most effective means of achieving compatibility with a texture atlas will involve actually
	using the faces themselves as a guide for achieving proper texture coordinates. This is because one vertex will likely
	be a vertex for 2 or more adjacent faces.

	In addition, it's clear that the faces which are rendered through bezier patches are also fairly messed up as far as their texture coordinates
	are concerned. This may be partially due to the modding (for the patch faces which are dealt with via effect shader) as well, but it's also
	possible there's a miscomputation being performed in one of the bspVertex_t operator overloads.

		Update (1:12 PM, 12/27): Modding in the shader is the way to go for repeated textures, and clamping the coordinates at their respective
		locations is also the way to go for clamped textures. However, there is a strange effect which is resulting from clamped textures.
		The decals (clamped textures) themselves in the current map being tested (Railgun_Arena) *will* produce the proper
		image, with the exception that every mapped pair of triangles will result in a white section being rendered in the upper right
		corner (maybe other areas as well?). This is definitely not due to any tcMods: one area in which this is prevelant is in aecell_decal_spawn1,
		which has none of these. 
		
		Considering that using applyTransform(vec2(1.0)) produces the correct ending coordinate within the atlas, it's clear that something
		else is amiss. Color blending is most likely not the problem, considering that everything works fine using texture arrays.
		
		The source of the issue may be due to interaction with the lightmaps, or an incorrect sampler being bound at the time of the draw call.
		The sampler simply may be improperly constructed, or it may just be the wrong one period. Verify that, when binding the sampler,
		the correct index is used.
		
		Also, something which needs to be done is to rewrite GBindTexture so it has this signature:
			void GBindTexture(handle, sampler = G_UNSPECIFIED)

		in the implementation, if sampler != G_UNSPECIFIED, then it should be bound.

- Models

- Lightvols

- Environment Maps:  
	While the drawsurfaces have neighboring/similar faces grouped together, it's very possible that there can be varying surface normals within a single drawsurface.
	This isn't good, because the renderer doesn't currently take this into account. It's going to need to be able to support this.

- Sorting shaders:
	Shaders are depth sorted against each other. What this means, exactly, I'm not sure, but this will need some more time to figure out.
	

- Game Units: 
	* Incorporating these into the renderer will be important: it should aid in ensuring that the scaling and spread of things like texture coordinates and
	deformed tessellations will be properly computed. (see: http://toolz.nexuizninjaz.com/shader/shader/section2.htm#2.4.2 section 2.4.7 "measurements")

- Ability to save camera position/orientation and load it later.


[2 - GL features which are not supported by WebGL]:
    (NOTE: mipmapping is currently disabled, to make the process of porting easier)
    (NOTE: localOverrideFlags which are added to teh shader/stages are not taken into account with the new image loading function)

    - UBOs
    - VAOs
    - Texture Arrays
    - GLSL Extensions
    - Current GLSL syntax/layer

    Progress
    ========
    - ###A few functions have been written to handle image loading and what-not. Next thing to do would be to implement a mechanism similar to
    ###the textureArray_t which uses features available only to GLES 2.

    - Now that the image loading has been taken care of,

    - Samplers
