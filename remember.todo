11/29/2015

- [Priority]:
	It's pretty clear that some very, very important things need to be done before moving on. The code base is pretty mangled, and things aren't as organized as they should be.
	
	[Major Tasks]:

	* This ties in with the environment maps; either way, you should redesign your draw surfaces to be matched by surfacenormal in addition to the other parameters
	they employ; this will allow for more flexibility, the caching and performance benefits will be retained, and you'll have a better working environment map.
	(NOTE: bsp vertices do have normals - you should definitely stop passing in face surface normals and pass the normals in as vertex attributes.
	You'll need to switch layouts obviously each time this is done, but if it works then it works).

    On the environment map: it appears that the st coords which are generated using the displacement on the reflected vector's XZ plane
    are actually producing the right values. HOWEVER, what also seems true is that something is rendering over it...which is either a) rendering
    out of order, b) using a bad material, or c) a poor color blending value. Any of these might be possible...


	* Break up the code in renderer.cpp into separately organized modules: the class is becoming disgustingly big, and there's a lot of "dead code"
	in there which shouldn't be used.
		- Be sure to take into account the fact that you'll need to sort 
		the shaders according to their specified heuristic.
		- You'll also need to support WebGL, which means getting rid of some things like texture arrays and UBOs.
		In order to achieve this, you'll be better off replacing them optimizations which have been proven
		(e.g., texture atlas). All uniforms for a shader parameter can be stored in something which is local
		in a separate rendering mechanism as well; this way, whenever a program is bound, it can load the values
		automatically (like the modelView matrix, etc). Emulated behavior isn't awesome, but it's better than
        nothing. See [2]

	* After you're finished refactoring, you'll want to work on the Emscripten port.

    [Notes]:

    * 1/3/2016 - Moved everything over to something more "ES Compliant". Effect shaders appear to work fine
    with the old school techniques. However, while the main render pass shader program WILL render both the
    lightmaps and the face images, the lightmaps appear to not blend properly with the image materials, for some reason....

	* There's a weird bug which causes strange color flashes, when the faces are rendered separately (i.e., without the draw surfaces). My guess is
    this is likely to do with the texture arrays (are they being unbound after the draw is made?), but I'm not sure.

    * For the texture atlas, the issue appears to be that images with dimensions that are the same size as the actual image slot
    can overlap into adjacent images through a clamp or a modf, with 1.0 as the denominator. In other words, one image's beginning
    ST coordinate is another image's ending ST slot - in the diagonal sense (however, this could also refer to adjacent images on
    a purely horizontal or vertical level). Passing in a mod value of 0.99 prevents the overlap from occurring. However, this really
    shouldn't be done, because it's clear that this isn't the complete solution. We need to come up with a workaround for this.

    I see a few approaches:
        * Add a small amount of padding in each slot, which prevents this from happening (maybe 1 pixel thick).
            You'd want it so that any image (which has dimensions equal to the slot's dimensions) won't
            be in conflict or overlap when an st coordinate of (1.0, 1.0) (from the vertex buffer, before transformation)
            is modded against the delimiter of (1.0, 1.0) - thus obviously producing zero. The border (which will also
            have a 0 for its alpha channel) will be landed on instead, preventing any issues.

        * Just check for max image size: images with sizes equal to the slot can be modded/clamped against vec2(0.99, 0.99) and
        other images can be modded/clamped against vec2(1.0, 1.0)

        So far, the second one is obviously simpler, and may be OK to work with for now. However, it should be noted that
        it's very possible using 0.99 with the max-sized images will cause us to lose significant portions of their content...

        so... ¯\_(ツ)_/¯ ; the first approach is probably A) the most interesting to study, and B) the most sensible...

- Models

- Lightvols

- Environment Maps:  
	While the drawsurfaces have neighboring/similar faces grouped together, it's very possible that there can be varying surface normals within a single drawsurface.
	This isn't good, because the renderer doesn't currently take this into account. It's going to need to be able to support this.

- Sorting shaders:
	Shaders are depth sorted against each other. What this means, exactly, I'm not sure, but this will need some more time to figure out.
	

- Game Units: 
	* Incorporating these into the renderer will be important: it should aid in ensuring that the scaling and spread of things like texture coordinates and
	deformed tessellations will be properly computed. (see: http://toolz.nexuizninjaz.com/shader/shader/section2.htm#2.4.2 section 2.4.7 "measurements")

- Ability to save camera position/orientation and load it later.


[2 - GL features which are not supported by WebGL]:
    (NOTE: mipmapping is currently disabled, to make the process of porting easier)
    (NOTE: localOverrideFlags which are added to teh shader/stages are not taken into account with the new image loading function)

    - UBOs
    - VAOs
    - Texture Arrays
    - GLSL Extensions
    - Current GLSL syntax/layer

    Progress
    ========
    - ###A few functions have been written to handle image loading and what-not. Next thing to do would be to implement a mechanism similar to
    ###the textureArray_t which uses features available only to GLES 2.

    - Now that the image loading has been taken care of,

    - Samplers
