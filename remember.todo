Feature:
//- Lightmaps; use a separate tex sampler for that ( almost done )
//- Textures; need to be mipmapped (priority)
//- Gamma correction
//- Anisotropy
- Billboards
- Shader parser
	* We'll need a struct for every shader entry. Research the file format to get a better idea.

- Models
- Lightvols

- Ability to save camera position/orientation and load it later.


Impl:
- Shaders:
	* The chunk of texture loading code used is good and should be saved. This is actually necessary, since effect shaders don't necessarily specify paths to all of the texture 
    assets listed in the folders.
	* Railgun_Arena.shader is your friend; use it as a basis to go off of before moving onto more complex layouts.
	* Test the map with the first draft of the parser when it's done. Think about the passes; each shader "name" (i.e., entry)
	  has a multi-tier layer of passes which begin after the globals are specified in its own entry: those are the passes to focus
	  on and consider. This likely ties into the "isSolid" bool variable which is passed into the DrawNode(...) function 
  
  TODO:
    //- Write a debug function which checks to see if a shader stage within an entry is a "stub" (an entry which wasn't parsed due to unsupported functionality);
     // for every stage which is a stub, use the default shader to render.
    
    - Start mapping out current usage for the renderer; look into testing shader entries with multiple passes ( aka "stages" ). 
      Also use glPolygonOffset to test entries which use that.
      
      //- Each shader stage should be its own GLSL program. 
      //- GLSL program generation will begin after the initial parsing is finished. Remember: this doesn't need to be perfect; it just needs to get the job done.
      
      - Uniform blocks should exist for global entry parameters, in addition to the standard view/projection transforms.
      
      //- effect shader structs are stored in a std::map file. The next step is to create textures for every light stage which which references a texture file; 
       // this texture data will be stored in the light stage itself. Sampler objects should be used. Also, be sure to review the differences between "map" and "clampmap"
       // keywords.
     
     // - In BSPRenderer::DrawFace - Iterate through the shader stages for every entity (the names of which are stored in the textures lump) and use the DrawFaceVerts function for every 
     
     //stage. If the face is a bezier patch, be sure to cache the subdivision level before passing it to the draw function.
     
     - Figure out where to go now; some lightmaps aren't being loaded (properly, at least) when the shaders are used, so that would probably be a good place to start.
     
     //- Merge shader_impl branch into master; let shader_impl overwrite any conflicts
     

  NOTES:
    - Eventually, all terms should default to lower case when read by the parser, to eliminate issues with case sensitivity

    //- Integrate Uniform Buffer Objects for matrix transformations
    - Look for other ways of optimizing the shaders; example, "conservative depth", for fragment discards.
    - Also, some resources for railgun_arena are missing. See if there's a workaround somehow around this.
    - Let Railgun_Arena.shader be the main focus for now.
    - TODO list ( in order of importance ):
      - lightmaps; test Railgun_Arena with other BSP renderer and compare to make sure this is working right;
        
        - Need to look into cull settings - this may alleviate some issues
      
      - vertexDeformation
        - On barycentric tessellation: 
          * understand how to traverse the entire surface. You might be able to do something along the means of a "scan-line".
          For example:
            for (height = 0; height <= 1.0f; height += step)
            {
              for (traverse = 1.0 - height; traverse >= 0; traverse -= step)
              {
                float right0 = 1.0 - traverse - height;
              }
            }

            height, traverse, and right0 will form a barycentric point p(p1, p2, p3).

            Where,

            p1 = traverse
            p2 = height
            p3 = right0

            traverse will flow from left to right.

            You need to find a means of producing two other points which will produce an equaliteral triangle.
            Remember: think about how, once p has been defined for any iteration, adding a value to any of the weights
            implies subtracting one from the other.

            let u be some constant in the range [0, 0.5]

            So, to add u to p3, you can subtract u from p1: this will effectively move the 
            point toward p3, while remaining at the same "level" (i.e., p2's value is still the same)

            here's c, the right point of the triangle:
              c1 = traverse - u
              c2 = height
              c3 = right0 + u

            and k, the top vertex:
              k1 = traverse - u * 0.5
              k2 = height
              k3 = right0 + u * 0.5

              This sets k between p and c. However, we still need to move it upwards while continuing to maintain the equation k1 + k2 + k3 = 1
              
              k1 = traverse - u * 0.5 - u
              k2 = height + u
              k3 = right0 + u * 0.5 - u

              Provided we have a 3x3 matrix with a column basis matching each world-space position of the triangle,
              we can take these weighted points and transform each one to produce corresponding world space points

        - it's important to verify whether or not the deformations should take place after a given triangle is subdivided, 
          *while* a given triangle is being subdivided (i.e., each subdivided triangle has the deform applied regardless of whether or not it's added
          to the subdivision list), or only after all subdivisions have been performed (i.e., performing a batch deform).

      - rgbGen ( need to test with other shaders )
      - tcMod 
      - depthWrite

Perf:
//- Use the same vao for the bezier patches that is being used for the rest of the data
//- Pre-construct face indices so they don't need to be re-computed every pass
//- Cache uniform locations
//- Minimize state changes as much as possible

( Cause of this hit seems to be mostly due to bezier patch LOD and running in debug mode. Lel...)
/*
- Testing on map "aty3dm1v2.bsp" produces some areas where there is a pretty bad drop in performance. The following is a list
  of things which are known to not be causes of the performance hit:
  - Rendering bezier patches
  - using alpha blending
  Things which have appeared to provide improvements:
  - Capping bezier tessellation level at 10
  - Improving the speed of the frustum collision loop by 8x
  - Moving glActiveTexture and the glUniform1i call used to set the sampler parameter out of the render loop.  
  */


Bug:
- Some bezier patches have a "reflection"-like artifact appearing on them. These look like Egyptian pots, and I think this may be due to the filtering...and maybe even wrap modes, 
though I'm not sure. Regardless, all of these specifics should be handled via the shader parser, as it will likely have the best configuration for a particular material.

- Plant meshes are just flat polygons that will render as black in areas where there is no image data for the texel. 
  As a result, any zero length fragment coming from a plant mesh in the fragment shader should just be discarded. Shader may provide info for this. 
  UPDATE: yes, it does. surfaceparms "trans" and "nonsolid" seem to be what we want.

- Artifacts which appear in various forms of the scenery (for example, the columns in "aty3dm1v2"). They look like little tiny sketches (or lines, rather) which appear 
  on the models in varying places as the camera moves around. If effect shader support doesn't fix this, this will need to be revisited. 
  UPDATE: this is likely what is known as "Z-Fighting". polygonoffset in the shaders should ammend any issues with this. 


Refactor:
  - Move all OpenGL utility functions into glutil.h (e.g., shader compilation and linking functions); ideally, any function which has an OpenGL call should be thrown in there.
//- All GL state management should be handled in ONE place.
//- Have a global interface function which can be called for setting the function source and call strings in GL_CHECK macro, as opposed to just directly setting globals...
//- Make all variables camelcase in gldebug.cpp
//- For consistency, remove std::vector usage from Q3BspMap class (as well as mapModel_t). Replace with buffers.
- Precompile headers...
//- Ditch malloc usage in Q3BspMap::Read(...) and call new instead. Also consider allocating one gigantic buffer, and then simply using pointers to point to the actual data in their respective memory formats.





